"""
协程是个什么东西呢？它是一种轻量级的，用户态的执行单元。它占用的内存非常少，
几乎是需要多少才用多少。相比起线程在创建之初就指定栈空间，协程所使用的内存可以动态地变化。它主要有两个特点：
占用的资源更少。
所有的切换和调度都发生在用户态。

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，
在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），
每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

在并发编程中，协程与线程类似，每个协程表示一个执行单元，有自己的本地数据，与其它协程共享全局数据和其它资源。
目前主流语言基本上都选择了多线程作为并发设施，
与线程相关的概念是抢占式多任务（Preemptive multitasking），而与协程相关的是协作式多任务。
"""

"""
不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。
而且由于抢占式调度执行顺序无法确定的特点，
使用线程时需要非常小心地处理同步问题，而协程完全不存在这个问题（事件驱动和异步程序也有同样的优点）。
协作式的任务，是要用户自己来负责任务的让出的。如果一个任务不主动让出，
其他任务就不会得到调度。这是协程的一个弱点，但是好好的规划，这其实是一个可以变得很强大的优点。


"""


# 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。
# 如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：


def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'


def produce(c):
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
c.send(None)
produce(c)